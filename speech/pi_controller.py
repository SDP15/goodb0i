import os
import queue
import socket
import sys
import threading
import time

import requests
import serial

from speech_interactor import SpeechInteractor
from utils.custom_threads import WorkerThread
from utils.product import Product
from utils.sockets import WebSocket, TCPSocket
# from qr_scanner_live import QRDetection


class PiController:
    def __init__(self):
        # Data structures for worker threads
        controller_queue = queue.Queue()
        self.speech_interactor_queue = queue.Queue()

        self.ip_port = "127.0.0.1:8080"
        self.ev3_ip = "192.168.105.108"
        self.ev3_port = 6081
        self.ws = WebSocket(self.ip_port, controller_queue).get_instance()
        self.ev3 = TCPSocket(self.ev3_ip, self.ev3_port, controller_queue)
        self.ev3_commands = []

        # TODO: Enqueue messages to be sent to WS and EV3 via PiControllerThread
        SpeechInteractor(self.ws, self.ev3, self.speech_interactor_queue)
        
        # Thread runs a given function and it's arguments (if given any) from the work queue
        t1 = WorkerThread("PiControllerThread", self, controller_queue)
        t1.start()

        # # To test receiving messages from WebSocket/to EV3
        # time.sleep(3)
        # self.ws.send("RouteCalculated&start,stop%3%0,pass%11")

        # time.sleep(2)
        # self.ws.send("ConfirmMessage&UserReady")

    def on_message(self, message):
        if "AppAcceptedProduct" in message:
            self.speech_interactor_queue.put(("next_state", "cart"))
            self.speech_interactor_queue.put(("cart", "yes", "app=True"))
        elif "AppRejectedProject" in message:
            self.speech_interactor_queue.put(("cart", "no", "app=True"))
        elif "AppScannedProduct" in message:
            item = message.split("&")
            query = "/products/" + item[1]
            item_json = self.query_web_server(query)

            id = item_json['id']
            name = item_json['name']
            price = item_json['price']
            new_product = Product(id, 1, name, price)
            self.speech_interactor_queue.put(("scanned", new_product))
        elif "RouteCalculated" in message:
            self.ordered_list = queue.Queue()
            self.marker_list = queue.Queue()
            self.ordered_shelves = []

            while not self.list_downloaded:
                pass

            #Message format: RouteCalculated&forward,right%shelf_number%index_of_item,forward
            full_route = message.split("&")
            route = full_route[1].split(",")

            # Queue to check if command has marker number
            self.route_commands = queue.Queue()
            
            # TODO: Change this
            for command in route:
                if command == "start" or command == "end":
                    continue
                self.route_commands.put(command)

            for commands in route:
                command = commands.split("%")
                #Route planning uses "pass" to indicate that we are going "forward" at a marker
                if command[0] == "pass":
                    command[0] = "forward"
                
                # If the command has more than one number after the command then it is a stop command
                # The numbers after are indices into the shopping list generated by the user this can be used to
                # order the shopping list.
                if command[0] != "start" and command[0] != "end":
                    if len(command) > 2:
                        for index in command[2:]:
                            self.ordered_list.put(self.unordered_list[int(index)])
                        # shelf = shelf.Shelf(command[1], command[2:])
                        # self.ordered_shelves.append(shelf)
                        self.marker_list.put(command[1])
                    elif len(command) > 1:
                        self.marker_list.put(command[1])

                    self.ev3_commands.append("enqueue-" + command[0])
            self.speech_interactor_queue.put(("set_list", self.ordered_list))
            self.ws.send("ReceivedRoute&")
            self.speech_interactor_queue.put(("react", "connected"))
        elif "Assigned" in message:
            self.list_downloaded = False
            list_message = message.split("&")
            list_id = list_message[1]
            self.get_shopping_list(list_id)
        elif "ConfirmMessage&UserReady" in message:
            # Server & pi ready to go => queue commands on EV3
            self.ev3.send("stop")
            self.ev3.send("resume-from-stop-marker")
            self.ev3.send("clear-queue")
            for command in self.ev3_commands:
                self.ev3.send(command)

            # Start following route
            self.ev3.send("start")
            self.speech_interactor_queue.put("set_moving")
        elif "detected-marker" in message:
            command = self.route_commands.get()
            if "%" in command:
                marker_num = self.marker_list.get()
                self.ws.send("ReachedPoint&" + marker_num)
            if "stop" in message:
                self.speech_interactor_queue.put("on_location_change")

    #the request parameter has to be in the correct format e.g. /lists/load/7654321
    def query_web_server(self, request):
        r = requests.get("http://"+self.ip_port + request)
        list_json = r.json()
        return list_json
     
    # Retrieves all the items and quantities on the shopping list.
    def get_shopping_list(self, list_file):
        r = requests.get("http://" + self.ip_port + "/lists/load/" + list_file)
        json  = r.json()
        self.unordered_list = []
        for products in json['products']:
            id = products['product']['id']
            quantity = products['quantity']
            name = products['product']['name']
            price = products['product']['price']
            new_product = Product(id, quantity, name, price)
            self.unordered_list.append(new_product)
        self.list_downloaded = True
        
    # def readline_tcpsocket(self, port):
    #     message = ""
    #     byte = ""
    #     while True:
    #         byte = port.read()
    #         if byte == "\n":
    #             break
    #         message += byte
    #     # TODO: NEED TO CHANGE THIS! 
    #     if message == self.marker_list[0]:
    #         self.sp_interactor.on_location_change()
    #         self.send_message(self.ws, "ReachPoint&" + message)
    #     else:
    #         print(message)
    #     return message

    # def scanned_qr_code(self, qr_code):
    #     print(qr_code)


PiController()
